/**
 * * This file was generated by the script generate-dts.ts;
 *
 * ! DO NOT MODIFY IT MANUALLY, ALL CHANGES WILL BE OVERWRITTEN !
 */

import type { CstNode, ICstVisitor, IToken } from "chevrotain";

export interface AlgorithmCstNode extends CstNode {
  name: "algorithm";
  children: AlgorithmCstChildren;
}

export type AlgorithmCstChildren = {
  header: HeaderCstNode[];
  constantsDeclarators?: ConstantsDeclaratorsCstNode[];
  variablesDeclarators?: VariablesDeclaratorsCstNode[];
  program: ProgramCstNode[];
};

export interface HeaderCstNode extends CstNode {
  name: "header";
  children: HeaderCstChildren;
}

export type HeaderCstChildren = {
  Algorithm: IToken[];
  Identifier: IToken[];
  SemiColon?: IToken[];
};

export interface ConstantsDeclaratorsCstNode extends CstNode {
  name: "constantsDeclarators";
  children: ConstantsDeclaratorsCstChildren;
}

export type ConstantsDeclaratorsCstChildren = {
  Constant: IToken[];
  Identifier: IToken[];
  AssignmentOperator: IToken[];
  expression: ExpressionCstNode[];
  SemiColon: (IToken)[];
};

export interface VariablesDeclaratorsCstNode extends CstNode {
  name: "variablesDeclarators";
  children: VariablesDeclaratorsCstChildren;
}

export type VariablesDeclaratorsCstChildren = {
  Variable: IToken[];
  variableDeclarator: VariableDeclaratorCstNode[];
  SemiColon: (IToken)[];
};

export interface ProgramCstNode extends CstNode {
  name: "program";
  children: ProgramCstChildren;
}

export type ProgramCstChildren = {
  Start: IToken[];
  statement: StatementCstNode[];
  End: IToken[];
};

export interface StatementCstNode extends CstNode {
  name: "statement";
  children: StatementCstChildren;
}

export type StatementCstChildren = {
  assignmentStatement?: AssignmentStatementCstNode[];
  controlStatements?: ControlStatementsCstNode[];
  operationsStatements?: OperationsStatementsCstNode[];
};

export interface AssignmentStatementCstNode extends CstNode {
  name: "assignmentStatement";
  children: AssignmentStatementCstChildren;
}

export type AssignmentStatementCstChildren = {
  assignmentExpression: AssignmentExpressionCstNode[];
  SemiColon: IToken[];
};

export interface ControlStatementsCstNode extends CstNode {
  name: "controlStatements";
  children: ControlStatementsCstChildren;
}

export type ControlStatementsCstChildren = {
  iterationStatements?: IterationStatementsCstNode[];
  conditionalStatements?: ConditionalStatementsCstNode[];
};

export interface OperationsStatementsCstNode extends CstNode {
  name: "operationsStatements";
  children: OperationsStatementsCstChildren;
}

export type OperationsStatementsCstChildren = {
  printExpression?: PrintExpressionCstNode[];
  readExpression?: ReadExpressionCstNode[];
};

export interface IterationStatementsCstNode extends CstNode {
  name: "iterationStatements";
  children: IterationStatementsCstChildren;
}

export type IterationStatementsCstChildren = {
  doWhileStatement?: DoWhileStatementCstNode[];
  whileDoStatement?: WhileDoStatementCstNode[];
  forLoopStatement?: ForLoopStatementCstNode[];
};

export interface DoWhileStatementCstNode extends CstNode {
  name: "doWhileStatement";
  children: DoWhileStatementCstChildren;
}

export type DoWhileStatementCstChildren = {
  Do: IToken[];
  block: BlockCstNode[];
  While: IToken[];
  LParen: IToken[];
  expression: ExpressionCstNode[];
  RParen: IToken[];
  SemiColon: IToken[];
};

export interface WhileDoStatementCstNode extends CstNode {
  name: "whileDoStatement";
  children: WhileDoStatementCstChildren;
}

export type WhileDoStatementCstChildren = {
  While: IToken[];
  LParen: IToken[];
  expression: ExpressionCstNode[];
  RParen: IToken[];
  Do: IToken[];
  block: BlockCstNode[];
};

export interface ForLoopStatementCstNode extends CstNode {
  name: "forLoopStatement";
  children: ForLoopStatementCstChildren;
}

export type ForLoopStatementCstChildren = {
  For: IToken[];
  LParen: IToken[];
  assignmentExpression: (AssignmentExpressionCstNode)[];
  SemiColon: (IToken)[];
  expression: ExpressionCstNode[];
  RParen: IToken[];
  Do: IToken[];
  block: BlockCstNode[];
};

export interface ConditionalStatementsCstNode extends CstNode {
  name: "conditionalStatements";
  children: ConditionalStatementsCstChildren;
}

export type ConditionalStatementsCstChildren = {
  ifStatement?: IfStatementCstNode[];
  switchStatement?: SwitchStatementCstNode[];
};

export interface IfStatementCstNode extends CstNode {
  name: "ifStatement";
  children: IfStatementCstChildren;
}

export type IfStatementCstChildren = {
  If: IToken[];
  LParen: IToken[];
  expression: ExpressionCstNode[];
  RParen: IToken[];
  Then: IToken[];
  block: BlockCstNode[];
  elseStatement?: ElseStatementCstNode[];
};

export interface ElseStatementCstNode extends CstNode {
  name: "elseStatement";
  children: ElseStatementCstChildren;
}

export type ElseStatementCstChildren = {
  Else: IToken[];
  ifStatement?: IfStatementCstNode[];
  block?: BlockCstNode[];
};

export interface SwitchStatementCstNode extends CstNode {
  name: "switchStatement";
  children: SwitchStatementCstChildren;
}

export type SwitchStatementCstChildren = {
  Switch: IToken[];
  variableAccess?: (VariableAccessCstNode)[];
  LParen?: IToken[];
  RParen?: IToken[];
  LCurly: IToken[];
  Case: IToken[];
  StringLiteral?: IToken[];
  Do: (IToken)[];
  block?: (BlockCstNode)[];
  Colon?: IToken[];
  statement?: StatementCstNode[];
  SemiColon?: IToken[];
  Default?: IToken[];
  RCurly: IToken[];
};

export interface ExpressionCstNode extends CstNode {
  name: "expression";
  children: ExpressionCstChildren;
}

export type ExpressionCstChildren = {
  ternaryExpression: TernaryExpressionCstNode[];
};

export interface TernaryExpressionCstNode extends CstNode {
  name: "ternaryExpression";
  children: TernaryExpressionCstChildren;
}

export type TernaryExpressionCstChildren = {
  binaryExpression: BinaryExpressionCstNode[];
  Question?: IToken[];
  expression?: (ExpressionCstNode)[];
  Colon?: IToken[];
};

export interface BinaryExpressionCstNode extends CstNode {
  name: "binaryExpression";
  children: BinaryExpressionCstChildren;
}

export type BinaryExpressionCstChildren = {
  unaryExpression: (UnaryExpressionCstNode)[];
  BinaryOperator?: IToken[];
};

export interface UnaryExpressionCstNode extends CstNode {
  name: "unaryExpression";
  children: UnaryExpressionCstChildren;
}

export type UnaryExpressionCstChildren = {
  primaryExpression: PrimaryExpressionCstNode[];
};

export interface PrimaryExpressionCstNode extends CstNode {
  name: "primaryExpression";
  children: PrimaryExpressionCstChildren;
}

export type PrimaryExpressionCstChildren = {
  variableAccess?: VariableAccessCstNode[];
  parenthesisExpression?: ParenthesisExpressionCstNode[];
};

export interface ParenthesisExpressionCstNode extends CstNode {
  name: "parenthesisExpression";
  children: ParenthesisExpressionCstChildren;
}

export type ParenthesisExpressionCstChildren = {
  UnaryPrefixOperator?: IToken[];
  LParen: IToken[];
  expression: ExpressionCstNode[];
  RParen: IToken[];
};

export interface AssignmentExpressionCstNode extends CstNode {
  name: "assignmentExpression";
  children: AssignmentExpressionCstChildren;
}

export type AssignmentExpressionCstChildren = {
  variableAccess: VariableAccessCstNode[];
  AssignmentOperator?: IToken[];
  expression?: ExpressionCstNode[];
  UnarySuffixOperator?: IToken[];
};

export interface PrintExpressionCstNode extends CstNode {
  name: "printExpression";
  children: PrintExpressionCstChildren;
}

export type PrintExpressionCstChildren = {
  Print: IToken[];
  expression: ExpressionCstNode[];
  Comma?: IToken[];
  SemiColon: IToken[];
};

export interface ReadExpressionCstNode extends CstNode {
  name: "readExpression";
  children: ReadExpressionCstChildren;
}

export type ReadExpressionCstChildren = {
  Read: IToken[];
  variableAccess: VariableAccessCstNode[];
  Comma?: IToken[];
  SemiColon: IToken[];
};

export interface VariableDeclaratorCstNode extends CstNode {
  name: "variableDeclarator";
  children: VariableDeclaratorCstChildren;
}

export type VariableDeclaratorCstChildren = {
  Identifier: IToken[];
  Comma?: IToken[];
  Colon: IToken[];
  PrimitiveTypes?: (IToken)[];
  ArrayType?: IToken[];
  arrayAccessSuffix?: ArrayAccessSuffixCstNode[];
  Of?: IToken[];
};

export interface VariableAccessCstNode extends CstNode {
  name: "variableAccess";
  children: VariableAccessCstChildren;
}

export type VariableAccessCstChildren = {
  Identifier: IToken[];
  arrayAccessSuffix?: ArrayAccessSuffixCstNode[];
};

export interface ArrayAccessSuffixCstNode extends CstNode {
  name: "arrayAccessSuffix";
  children: ArrayAccessSuffixCstChildren;
}

export type ArrayAccessSuffixCstChildren = {
  LSquare: IToken[];
  Identifier?: IToken[];
  NumberLiteral?: IToken[];
  RSquare: IToken[];
};

export interface BlockCstNode extends CstNode {
  name: "block";
  children: BlockCstChildren;
}

export type BlockCstChildren = {
  LCurly: IToken[];
  statement: StatementCstNode[];
  RCurly: IToken[];
};

export interface ICstNodeVisitor<IN, OUT> extends ICstVisitor<IN, OUT> {
  algorithm(children: AlgorithmCstChildren, param?: IN): OUT;
  header(children: HeaderCstChildren, param?: IN): OUT;
  constantsDeclarators(children: ConstantsDeclaratorsCstChildren, param?: IN): OUT;
  variablesDeclarators(children: VariablesDeclaratorsCstChildren, param?: IN): OUT;
  program(children: ProgramCstChildren, param?: IN): OUT;
  statement(children: StatementCstChildren, param?: IN): OUT;
  assignmentStatement(children: AssignmentStatementCstChildren, param?: IN): OUT;
  controlStatements(children: ControlStatementsCstChildren, param?: IN): OUT;
  operationsStatements(children: OperationsStatementsCstChildren, param?: IN): OUT;
  iterationStatements(children: IterationStatementsCstChildren, param?: IN): OUT;
  doWhileStatement(children: DoWhileStatementCstChildren, param?: IN): OUT;
  whileDoStatement(children: WhileDoStatementCstChildren, param?: IN): OUT;
  forLoopStatement(children: ForLoopStatementCstChildren, param?: IN): OUT;
  conditionalStatements(children: ConditionalStatementsCstChildren, param?: IN): OUT;
  ifStatement(children: IfStatementCstChildren, param?: IN): OUT;
  elseStatement(children: ElseStatementCstChildren, param?: IN): OUT;
  switchStatement(children: SwitchStatementCstChildren, param?: IN): OUT;
  expression(children: ExpressionCstChildren, param?: IN): OUT;
  ternaryExpression(children: TernaryExpressionCstChildren, param?: IN): OUT;
  binaryExpression(children: BinaryExpressionCstChildren, param?: IN): OUT;
  unaryExpression(children: UnaryExpressionCstChildren, param?: IN): OUT;
  primaryExpression(children: PrimaryExpressionCstChildren, param?: IN): OUT;
  parenthesisExpression(children: ParenthesisExpressionCstChildren, param?: IN): OUT;
  assignmentExpression(children: AssignmentExpressionCstChildren, param?: IN): OUT;
  printExpression(children: PrintExpressionCstChildren, param?: IN): OUT;
  readExpression(children: ReadExpressionCstChildren, param?: IN): OUT;
  variableDeclarator(children: VariableDeclaratorCstChildren, param?: IN): OUT;
  variableAccess(children: VariableAccessCstChildren, param?: IN): OUT;
  arrayAccessSuffix(children: ArrayAccessSuffixCstChildren, param?: IN): OUT;
  block(children: BlockCstChildren, param?: IN): OUT;
}

export type CstNodeTypes = {
  algorithm: AlgorithmCstNode;
  header: HeaderCstNode;
  constantsDeclarators: ConstantsDeclaratorsCstNode;
  variablesDeclarators: VariablesDeclaratorsCstNode;
  program: ProgramCstNode;
  statement: StatementCstNode;
  assignmentStatement: AssignmentStatementCstNode;
  controlStatements: ControlStatementsCstNode;
  operationsStatements: OperationsStatementsCstNode;
  iterationStatements: IterationStatementsCstNode;
  doWhileStatement: DoWhileStatementCstNode;
  whileDoStatement: WhileDoStatementCstNode;
  forLoopStatement: ForLoopStatementCstNode;
  conditionalStatements: ConditionalStatementsCstNode;
  ifStatement: IfStatementCstNode;
  elseStatement: ElseStatementCstNode;
  switchStatement: SwitchStatementCstNode;
  expression: ExpressionCstNode;
  ternaryExpression: TernaryExpressionCstNode;
  binaryExpression: BinaryExpressionCstNode;
  unaryExpression: UnaryExpressionCstNode;
  primaryExpression: PrimaryExpressionCstNode;
  parenthesisExpression: ParenthesisExpressionCstNode;
  assignmentExpression: AssignmentExpressionCstNode;
  printExpression: PrintExpressionCstNode;
  readExpression: ReadExpressionCstNode;
  variableDeclarator: VariableDeclaratorCstNode;
  variableAccess: VariableAccessCstNode;
  arrayAccessSuffix: ArrayAccessSuffixCstNode;
  block: BlockCstNode;
};
