/**
 * * This file was generated by the script generate-dts.ts;
 *
 * ! DO NOT MODIFY IT MANUALLY, ALL CHANGES WILL BE OVERWRITTEN !
 */

import type { CstNode, ICstVisitor, IToken } from "chevrotain";

export interface ProgramCstNode extends CstNode {
  name: "program";
  children: ProgramCstChildren;
}

export type ProgramCstChildren = {
  header: HeaderCstNode[];
  constDefinition?: ConstDefinitionCstNode[];
  varDefinition?: VarDefinitionCstNode[];
  algorithm: AlgorithmCstNode[];
};

export interface HeaderCstNode extends CstNode {
  name: "header";
  children: HeaderCstChildren;
}

export type HeaderCstChildren = {
  Algorithm: IToken[];
  Identifier?: IToken[];
  StringLiteral?: IToken[];
  SemiColon?: IToken[];
};

export interface ConstDefinitionCstNode extends CstNode {
  name: "constDefinition";
  children: ConstDefinitionCstChildren;
}

export type ConstDefinitionCstChildren = {
  Constant: IToken[];
  StrictAssignmentExpression: (StrictAssignmentExpressionCstNode)[];
  SemiColon: (IToken)[];
};

export interface VarDefinitionCstNode extends CstNode {
  name: "varDefinition";
  children: VarDefinitionCstChildren;
}

export type VarDefinitionCstChildren = {
  Variable: IToken[];
  VariableDeclaration?: VariableDeclarationCstNode[];
};

export interface VariableIdCstNode extends CstNode {
  name: "VariableId";
  children: VariableIdCstChildren;
}

export type VariableIdCstChildren = {
  Identifier?: (IToken)[];
  ArrayAccessors?: ArrayAccessorsCstNode[];
};

export interface VariableDeclarationCstNode extends CstNode {
  name: "VariableDeclaration";
  children: VariableDeclarationCstChildren;
}

export type VariableDeclarationCstChildren = {
  Identifier: (IToken)[];
  Comma?: IToken[];
  Colon: IToken[];
  TypeKeyword: TypeKeywordCstNode[];
  SemiColon: IToken[];
};

export interface AssignmentExpressionCstNode extends CstNode {
  name: "AssignmentExpression";
  children: AssignmentExpressionCstChildren;
}

export type AssignmentExpressionCstChildren = {
  VariableId: VariableIdCstNode[];
  AssignmentOperator: IToken[];
  Expression: ExpressionCstNode[];
};

export interface StrictAssignmentExpressionCstNode extends CstNode {
  name: "StrictAssignmentExpression";
  children: StrictAssignmentExpressionCstChildren;
}

export type StrictAssignmentExpressionCstChildren = {
  Identifier: IToken[];
  AssignmentOperator: IToken[];
  Expression: ExpressionCstNode[];
};

export interface ValueCstNode extends CstNode {
  name: "Value";
  children: ValueCstChildren;
}

export type ValueCstChildren = {
  Identifier?: IToken[];
  NumberLiteral?: IToken[];
  StringLiteral?: IToken[];
  True?: IToken[];
  False?: IToken[];
  Null?: IToken[];
};

export interface ArrayAccessorCstNode extends CstNode {
  name: "ArrayAccessor";
  children: ArrayAccessorCstChildren;
}

export type ArrayAccessorCstChildren = {
  LSquare: IToken[];
  Identifier?: IToken[];
  NumberLiteral?: IToken[];
  RSquare: IToken[];
};

export interface ArrayAccessorsCstNode extends CstNode {
  name: "ArrayAccessors";
  children: ArrayAccessorsCstChildren;
}

export type ArrayAccessorsCstChildren = {
  ArrayAccessor: (ArrayAccessorCstNode)[];
};

export interface TypeKeywordCstNode extends CstNode {
  name: "TypeKeyword";
  children: TypeKeywordCstChildren;
}

export type TypeKeywordCstChildren = {
  RealType?: IToken[];
  IntegerType?: IToken[];
  CharType?: IToken[];
  TextType?: IToken[];
  BooleanType?: IToken[];
  ArrayType?: IToken[];
  ArrayAccessors?: ArrayAccessorsCstNode[];
  Of?: IToken[];
  TypeKeyword?: TypeKeywordCstNode[];
};

export interface AlgorithmCstNode extends CstNode {
  name: "algorithm";
  children: AlgorithmCstChildren;
}

export type AlgorithmCstChildren = {
  Start: IToken[];
  Statement?: StatementCstNode[];
  End: IToken[];
};

export interface StatementCstNode extends CstNode {
  name: "Statement";
  children: StatementCstChildren;
}

export type StatementCstChildren = {
  AssignmentExpression?: AssignmentExpressionCstNode[];
  SemiColon?: IToken[];
  Block?: BlockCstNode[];
  IfStatement?: IfStatementCstNode[];
  IterationStatement?: IterationStatementCstNode[];
  UnaryExpression?: UnaryExpressionCstNode[];
};

export interface BlockCstNode extends CstNode {
  name: "Block";
  children: BlockCstChildren;
}

export type BlockCstChildren = {
  LCurly: IToken[];
  Statement?: StatementCstNode[];
  RCurly: IToken[];
};

export interface ExpressionCstNode extends CstNode {
  name: "Expression";
  children: ExpressionCstChildren;
}

export type ExpressionCstChildren = {
  BinaryExpression: BinaryExpressionCstNode[];
};

export interface BinaryExpressionCstNode extends CstNode {
  name: "BinaryExpression";
  children: BinaryExpressionCstChildren;
}

export type BinaryExpressionCstChildren = {
  BinaryExpressionDeclaration: (BinaryExpressionDeclarationCstNode)[];
  Operators?: OperatorsCstNode[];
};

export interface BinaryExpressionDeclarationCstNode extends CstNode {
  name: "BinaryExpressionDeclaration";
  children: BinaryExpressionDeclarationCstChildren;
}

export type BinaryExpressionDeclarationCstChildren = {
  Value?: ValueCstNode[];
  NotOperator?: NotOperatorCstNode[];
  LParen?: IToken[];
  Expression?: ExpressionCstNode[];
  RParen?: IToken[];
};

export interface OperatorsCstNode extends CstNode {
  name: "Operators";
  children: OperatorsCstChildren;
}

export type OperatorsCstChildren = {
  RelationalOperator?: RelationalOperatorCstNode[];
  MultiplicativeOperator?: MultiplicativeOperatorCstNode[];
  AdditiveOperator?: AdditiveOperatorCstNode[];
  LogicalOperator?: LogicalOperatorCstNode[];
};

export interface RelationalOperatorCstNode extends CstNode {
  name: "RelationalOperator";
  children: RelationalOperatorCstChildren;
}

export type RelationalOperatorCstChildren = {
  GreaterThan?: (IToken)[];
  Equals?: (IToken)[];
  LessThan?: (IToken)[];
  NotOperator?: NotOperatorCstNode[];
};

export interface NotOperatorCstNode extends CstNode {
  name: "NotOperator";
  children: NotOperatorCstChildren;
}

export type NotOperatorCstChildren = {
  Exclamation?: IToken[];
  Tilde?: IToken[];
  Not?: IToken[];
};

export interface MultiplicativeOperatorCstNode extends CstNode {
  name: "MultiplicativeOperator";
  children: MultiplicativeOperatorCstChildren;
}

export type MultiplicativeOperatorCstChildren = {
  Star?: IToken[];
  Slash?: IToken[];
};

export interface AdditiveOperatorCstNode extends CstNode {
  name: "AdditiveOperator";
  children: AdditiveOperatorCstChildren;
}

export type AdditiveOperatorCstChildren = {
  Plus?: IToken[];
  Minus?: IToken[];
};

export interface LogicalOperatorCstNode extends CstNode {
  name: "LogicalOperator";
  children: LogicalOperatorCstChildren;
}

export type LogicalOperatorCstChildren = {
  And?: IToken[];
  Or?: IToken[];
};

export interface IfStatementCstNode extends CstNode {
  name: "IfStatement";
  children: IfStatementCstChildren;
}

export type IfStatementCstChildren = {
  If: IToken[];
  LParen: IToken[];
  Expression: ExpressionCstNode[];
  RParen: IToken[];
  Then: IToken[];
  Block: BlockCstNode[];
  ElseStatement?: ElseStatementCstNode[];
};

export interface ElseStatementCstNode extends CstNode {
  name: "ElseStatement";
  children: ElseStatementCstChildren;
}

export type ElseStatementCstChildren = {
  Else: IToken[];
  IfStatement?: IfStatementCstNode[];
  Block?: BlockCstNode[];
};

export interface IterationStatementCstNode extends CstNode {
  name: "IterationStatement";
  children: IterationStatementCstChildren;
}

export type IterationStatementCstChildren = {
  Do?: (IToken)[];
  Block?: (BlockCstNode)[];
  While?: (IToken)[];
  LParen?: (IToken)[];
  Expression?: (ExpressionCstNode)[];
  RParen?: (IToken)[];
  SemiColon?: (IToken)[];
  For?: IToken[];
  AssignmentExpression?: (AssignmentExpressionCstNode)[];
};

export interface UnaryExpressionCstNode extends CstNode {
  name: "UnaryExpression";
  children: UnaryExpressionCstChildren;
}

export type UnaryExpressionCstChildren = {
  PrintOperator?: PrintOperatorCstNode[];
  ReadOperator?: ReadOperatorCstNode[];
};

export interface PrintOperatorCstNode extends CstNode {
  name: "PrintOperator";
  children: PrintOperatorCstChildren;
}

export type PrintOperatorCstChildren = {
  Print: IToken[];
  Expression: (ExpressionCstNode)[];
  Comma?: IToken[];
  SemiColon: IToken[];
};

export interface ReadOperatorCstNode extends CstNode {
  name: "ReadOperator";
  children: ReadOperatorCstChildren;
}

export type ReadOperatorCstChildren = {
  Read: IToken[];
  VariableId: (VariableIdCstNode)[];
  Comma?: IToken[];
  SemiColon: IToken[];
};

export interface ICstNodeVisitor<IN, OUT> extends ICstVisitor<IN, OUT> {
  program(children: ProgramCstChildren, param?: IN): OUT;
  header(children: HeaderCstChildren, param?: IN): OUT;
  constDefinition(children: ConstDefinitionCstChildren, param?: IN): OUT;
  varDefinition(children: VarDefinitionCstChildren, param?: IN): OUT;
  VariableId(children: VariableIdCstChildren, param?: IN): OUT;
  VariableDeclaration(children: VariableDeclarationCstChildren, param?: IN): OUT;
  AssignmentExpression(children: AssignmentExpressionCstChildren, param?: IN): OUT;
  StrictAssignmentExpression(children: StrictAssignmentExpressionCstChildren, param?: IN): OUT;
  Value(children: ValueCstChildren, param?: IN): OUT;
  ArrayAccessor(children: ArrayAccessorCstChildren, param?: IN): OUT;
  ArrayAccessors(children: ArrayAccessorsCstChildren, param?: IN): OUT;
  TypeKeyword(children: TypeKeywordCstChildren, param?: IN): OUT;
  algorithm(children: AlgorithmCstChildren, param?: IN): OUT;
  Statement(children: StatementCstChildren, param?: IN): OUT;
  Block(children: BlockCstChildren, param?: IN): OUT;
  Expression(children: ExpressionCstChildren, param?: IN): OUT;
  BinaryExpression(children: BinaryExpressionCstChildren, param?: IN): OUT;
  BinaryExpressionDeclaration(children: BinaryExpressionDeclarationCstChildren, param?: IN): OUT;
  Operators(children: OperatorsCstChildren, param?: IN): OUT;
  RelationalOperator(children: RelationalOperatorCstChildren, param?: IN): OUT;
  NotOperator(children: NotOperatorCstChildren, param?: IN): OUT;
  MultiplicativeOperator(children: MultiplicativeOperatorCstChildren, param?: IN): OUT;
  AdditiveOperator(children: AdditiveOperatorCstChildren, param?: IN): OUT;
  LogicalOperator(children: LogicalOperatorCstChildren, param?: IN): OUT;
  IfStatement(children: IfStatementCstChildren, param?: IN): OUT;
  ElseStatement(children: ElseStatementCstChildren, param?: IN): OUT;
  IterationStatement(children: IterationStatementCstChildren, param?: IN): OUT;
  UnaryExpression(children: UnaryExpressionCstChildren, param?: IN): OUT;
  PrintOperator(children: PrintOperatorCstChildren, param?: IN): OUT;
  ReadOperator(children: ReadOperatorCstChildren, param?: IN): OUT;
}

