/**
 * * This file was generated by the script generate-dts.ts;
 *
 * ! DO NOT MODIFY IT MANUALLY, ALL CHANGES WILL BE OVERWRITTEN !
 */

import type { CstNode, ICstVisitor, IToken } from "chevrotain";

export interface AlgorithmCstNode extends CstNode {
  name: "algorithm";
  children: AlgorithmCstContext;
}

export type AlgorithmCstContext = {
  header: HeaderCstNode[];
  typesDeclarators?: TypesDeclaratorsCstNode[];
  constantsDeclarators?: ConstantsDeclaratorsCstNode[];
  variablesDeclarators?: VariablesDeclaratorsCstNode[];
  program: ProgramCstNode[];
};

export interface HeaderCstNode extends CstNode {
  name: "header";
  children: HeaderCstContext;
}

export type HeaderCstContext = {
  Algorithm: IToken[];
  Identifier: IToken[];
  SemiColon?: IToken[];
};

export interface TypesDeclaratorsCstNode extends CstNode {
  name: "typesDeclarators";
  children: TypesDeclaratorsCstContext;
}

export type TypesDeclaratorsCstContext = {
  Type: IToken[];
  enumDeclarator?: EnumDeclaratorCstNode[];
};

export interface ConstantsDeclaratorsCstNode extends CstNode {
  name: "constantsDeclarators";
  children: ConstantsDeclaratorsCstContext;
}

export type ConstantsDeclaratorsCstContext = {
  Constant: IToken[];
  Identifier?: IToken[];
  AssignmentOperator?: IToken[];
  expression?: ExpressionCstNode[];
  SemiColon?: IToken[];
};

export interface VariablesDeclaratorsCstNode extends CstNode {
  name: "variablesDeclarators";
  children: VariablesDeclaratorsCstContext;
}

export type VariablesDeclaratorsCstContext = {
  Variable: IToken[];
  variableDeclarator?: VariableDeclaratorCstNode[];
  SemiColon?: IToken[];
};

export interface ProgramCstNode extends CstNode {
  name: "program";
  children: ProgramCstContext;
}

export type ProgramCstContext = {
  Start: IToken[];
  statement: StatementCstNode[];
  End: IToken[];
};

export interface StatementCstNode extends CstNode {
  name: "statement";
  children: StatementCstContext;
}

export type StatementCstContext = {
  assignmentStatement?: AssignmentStatementCstNode[];
  controlStatements?: ControlStatementsCstNode[];
  operationsStatements?: OperationsStatementsCstNode[];
};

export interface AssignmentStatementCstNode extends CstNode {
  name: "assignmentStatement";
  children: AssignmentStatementCstContext;
}

export type AssignmentStatementCstContext = {
  assignmentExpression: AssignmentExpressionCstNode[];
  SemiColon: IToken[];
};

export interface ControlStatementsCstNode extends CstNode {
  name: "controlStatements";
  children: ControlStatementsCstContext;
}

export type ControlStatementsCstContext = {
  iterationStatements?: IterationStatementsCstNode[];
  conditionalStatements?: ConditionalStatementsCstNode[];
};

export interface OperationsStatementsCstNode extends CstNode {
  name: "operationsStatements";
  children: OperationsStatementsCstContext;
}

export type OperationsStatementsCstContext = {
  printExpression?: PrintExpressionCstNode[];
  readExpression?: ReadExpressionCstNode[];
};

export interface IterationStatementsCstNode extends CstNode {
  name: "iterationStatements";
  children: IterationStatementsCstContext;
}

export type IterationStatementsCstContext = {
  doWhileStatement?: DoWhileStatementCstNode[];
  whileDoStatement?: WhileDoStatementCstNode[];
  forLoopStatement?: ForLoopStatementCstNode[];
};

export interface DoWhileStatementCstNode extends CstNode {
  name: "doWhileStatement";
  children: DoWhileStatementCstContext;
}

export type DoWhileStatementCstContext = {
  Do: IToken[];
  block: BlockCstNode[];
  While: IToken[];
  LParen: IToken[];
  expression: ExpressionCstNode[];
  RParen: IToken[];
  SemiColon: IToken[];
};

export interface WhileDoStatementCstNode extends CstNode {
  name: "whileDoStatement";
  children: WhileDoStatementCstContext;
}

export type WhileDoStatementCstContext = {
  While: IToken[];
  LParen: IToken[];
  expression: ExpressionCstNode[];
  RParen: IToken[];
  Do: IToken[];
  block: BlockCstNode[];
};

export interface ForLoopStatementCstNode extends CstNode {
  name: "forLoopStatement";
  children: ForLoopStatementCstContext;
}

export type ForLoopStatementCstContext = {
  For: IToken[];
  LParen: IToken[];
  assignmentExpression: (AssignmentExpressionCstNode)[];
  SemiColon: (IToken)[];
  expression: ExpressionCstNode[];
  RParen: IToken[];
  Do: IToken[];
  block: BlockCstNode[];
};

export interface ConditionalStatementsCstNode extends CstNode {
  name: "conditionalStatements";
  children: ConditionalStatementsCstContext;
}

export type ConditionalStatementsCstContext = {
  ifStatement?: IfStatementCstNode[];
  switchStatement?: SwitchStatementCstNode[];
};

export interface IfStatementCstNode extends CstNode {
  name: "ifStatement";
  children: IfStatementCstContext;
}

export type IfStatementCstContext = {
  If: IToken[];
  LParen: IToken[];
  expression: ExpressionCstNode[];
  RParen: IToken[];
  Then: IToken[];
  block: BlockCstNode[];
  elseStatement?: ElseStatementCstNode[];
};

export interface ElseStatementCstNode extends CstNode {
  name: "elseStatement";
  children: ElseStatementCstContext;
}

export type ElseStatementCstContext = {
  Else: IToken[];
  ifStatement?: IfStatementCstNode[];
  block?: BlockCstNode[];
};

export interface SwitchStatementCstNode extends CstNode {
  name: "switchStatement";
  children: SwitchStatementCstContext;
}

export type SwitchStatementCstContext = {
  Switch: IToken[];
  variableAccess?: (VariableAccessCstNode)[];
  LParen?: IToken[];
  RParen?: IToken[];
  LCurly: IToken[];
  Case: IToken[];
  StringLiteral?: IToken[];
  Do: (IToken)[];
  block?: (BlockCstNode)[];
  Colon?: IToken[];
  statement?: StatementCstNode[];
  Default?: IToken[];
  RCurly: IToken[];
};

export interface ExpressionCstNode extends CstNode {
  name: "expression";
  children: ExpressionCstContext;
}

export type ExpressionCstContext = {
  ternaryExpression: TernaryExpressionCstNode[];
};

export interface TernaryExpressionCstNode extends CstNode {
  name: "ternaryExpression";
  children: TernaryExpressionCstContext;
}

export type TernaryExpressionCstContext = {
  additionExpression: AdditionExpressionCstNode[];
  Question?: IToken[];
  expression?: (ExpressionCstNode)[];
  Colon?: IToken[];
};

export interface AdditionExpressionCstNode extends CstNode {
  name: "additionExpression";
  children: AdditionExpressionCstContext;
}

export type AdditionExpressionCstContext = {
  multiplicationExpression: (MultiplicationExpressionCstNode)[];
  Plus?: IToken[];
  Minus?: IToken[];
};

export interface MultiplicationExpressionCstNode extends CstNode {
  name: "multiplicationExpression";
  children: MultiplicationExpressionCstContext;
}

export type MultiplicationExpressionCstContext = {
  logicalExpression: (LogicalExpressionCstNode)[];
  Star?: IToken[];
  Slash?: IToken[];
  Modulo?: IToken[];
};

export interface LogicalExpressionCstNode extends CstNode {
  name: "logicalExpression";
  children: LogicalExpressionCstContext;
}

export type LogicalExpressionCstContext = {
  relationalExpression: (RelationalExpressionCstNode)[];
  LogicalOperator?: IToken[];
};

export interface RelationalExpressionCstNode extends CstNode {
  name: "relationalExpression";
  children: RelationalExpressionCstContext;
}

export type RelationalExpressionCstContext = {
  unaryExpression: (UnaryExpressionCstNode)[];
  RelationalOperator?: IToken[];
};

export interface UnaryExpressionCstNode extends CstNode {
  name: "unaryExpression";
  children: UnaryExpressionCstContext;
}

export type UnaryExpressionCstContext = {
  UnaryPrefixOperator?: IToken[];
  Literal?: IToken[];
  variableAccess?: VariableAccessCstNode[];
  parenthesisExpression?: ParenthesisExpressionCstNode[];
};

export interface ParenthesisExpressionCstNode extends CstNode {
  name: "parenthesisExpression";
  children: ParenthesisExpressionCstContext;
}

export type ParenthesisExpressionCstContext = {
  LParen: IToken[];
  expression: ExpressionCstNode[];
  RParen: IToken[];
};

export interface AssignmentExpressionCstNode extends CstNode {
  name: "assignmentExpression";
  children: AssignmentExpressionCstContext;
}

export type AssignmentExpressionCstContext = {
  variableAccess: VariableAccessCstNode[];
  AssignmentOperator?: IToken[];
  expression?: ExpressionCstNode[];
  UnarySuffixOperator?: IToken[];
};

export interface PrintExpressionCstNode extends CstNode {
  name: "printExpression";
  children: PrintExpressionCstContext;
}

export type PrintExpressionCstContext = {
  Print: IToken[];
  expression: ExpressionCstNode[];
  Comma?: IToken[];
  SemiColon: IToken[];
};

export interface ReadExpressionCstNode extends CstNode {
  name: "readExpression";
  children: ReadExpressionCstContext;
}

export type ReadExpressionCstContext = {
  Read: IToken[];
  variableAccess: VariableAccessCstNode[];
  Comma?: IToken[];
  SemiColon: IToken[];
};

export interface VariableDeclaratorCstNode extends CstNode {
  name: "variableDeclarator";
  children: VariableDeclaratorCstContext;
}

export type VariableDeclaratorCstContext = {
  Identifier: IToken[];
  Comma?: IToken[];
  Colon: IToken[];
  PrimitiveTypes?: (IToken)[];
  ArrayType?: IToken[];
  arrayAccessSuffix?: ArrayAccessSuffixCstNode[];
  Of?: IToken[];
};

export interface VariableAccessCstNode extends CstNode {
  name: "variableAccess";
  children: VariableAccessCstContext;
}

export type VariableAccessCstContext = {
  Identifier: IToken[];
  arrayAccessSuffix?: ArrayAccessSuffixCstNode[];
};

export interface EnumDeclaratorCstNode extends CstNode {
  name: "enumDeclarator";
  children: EnumDeclaratorCstContext;
}

export type EnumDeclaratorCstContext = {
  Identifier: (IToken)[];
  Colon: IToken[];
  Enum: IToken[];
  LCurly: IToken[];
  AssignmentOperator?: IToken[];
  NumberLiteral?: IToken[];
  Comma?: IToken[];
  RCurly: IToken[];
  SemiColon: IToken[];
};

export interface ArrayAccessSuffixCstNode extends CstNode {
  name: "arrayAccessSuffix";
  children: ArrayAccessSuffixCstContext;
}

export type ArrayAccessSuffixCstContext = {
  arrayAccess: ArrayAccessCstNode[];
};

export interface ArrayAccessCstNode extends CstNode {
  name: "arrayAccess";
  children: ArrayAccessCstContext;
}

export type ArrayAccessCstContext = {
  LSquare: IToken[];
  Identifier?: IToken[];
  NumberLiteral?: IToken[];
  RSquare: IToken[];
};

export interface BlockCstNode extends CstNode {
  name: "block";
  children: BlockCstContext;
}

export type BlockCstContext = {
  LCurly: IToken[];
  statement: StatementCstNode[];
  RCurly: IToken[];
};

export interface ICstNodeVisitor<IN, OUT> extends ICstVisitor<IN, OUT> {
  algorithm(ctx: AlgorithmCstContext, param?: IN): OUT;
  header(ctx: HeaderCstContext, param?: IN): OUT;
  typesDeclarators(ctx: TypesDeclaratorsCstContext, param?: IN): OUT;
  constantsDeclarators(ctx: ConstantsDeclaratorsCstContext, param?: IN): OUT;
  variablesDeclarators(ctx: VariablesDeclaratorsCstContext, param?: IN): OUT;
  program(ctx: ProgramCstContext, param?: IN): OUT;
  statement(ctx: StatementCstContext, param?: IN): OUT;
  assignmentStatement(ctx: AssignmentStatementCstContext, param?: IN): OUT;
  controlStatements(ctx: ControlStatementsCstContext, param?: IN): OUT;
  operationsStatements(ctx: OperationsStatementsCstContext, param?: IN): OUT;
  iterationStatements(ctx: IterationStatementsCstContext, param?: IN): OUT;
  doWhileStatement(ctx: DoWhileStatementCstContext, param?: IN): OUT;
  whileDoStatement(ctx: WhileDoStatementCstContext, param?: IN): OUT;
  forLoopStatement(ctx: ForLoopStatementCstContext, param?: IN): OUT;
  conditionalStatements(ctx: ConditionalStatementsCstContext, param?: IN): OUT;
  ifStatement(ctx: IfStatementCstContext, param?: IN): OUT;
  elseStatement(ctx: ElseStatementCstContext, param?: IN): OUT;
  switchStatement(ctx: SwitchStatementCstContext, param?: IN): OUT;
  expression(ctx: ExpressionCstContext, param?: IN): OUT;
  ternaryExpression(ctx: TernaryExpressionCstContext, param?: IN): OUT;
  additionExpression(ctx: AdditionExpressionCstContext, param?: IN): OUT;
  multiplicationExpression(ctx: MultiplicationExpressionCstContext, param?: IN): OUT;
  logicalExpression(ctx: LogicalExpressionCstContext, param?: IN): OUT;
  relationalExpression(ctx: RelationalExpressionCstContext, param?: IN): OUT;
  unaryExpression(ctx: UnaryExpressionCstContext, param?: IN): OUT;
  parenthesisExpression(ctx: ParenthesisExpressionCstContext, param?: IN): OUT;
  assignmentExpression(ctx: AssignmentExpressionCstContext, param?: IN): OUT;
  printExpression(ctx: PrintExpressionCstContext, param?: IN): OUT;
  readExpression(ctx: ReadExpressionCstContext, param?: IN): OUT;
  variableDeclarator(ctx: VariableDeclaratorCstContext, param?: IN): OUT;
  variableAccess(ctx: VariableAccessCstContext, param?: IN): OUT;
  enumDeclarator(ctx: EnumDeclaratorCstContext, param?: IN): OUT;
  arrayAccessSuffix(ctx: ArrayAccessSuffixCstContext, param?: IN): OUT;
  arrayAccess(ctx: ArrayAccessCstContext, param?: IN): OUT;
  block(ctx: BlockCstContext, param?: IN): OUT;
}

/**
 * Individual Visitors interfaces
 */
export interface AlgorithmVisitor<OUT = void> { algorithm(ctx: AlgorithmCstContext): OUT }
export interface HeaderVisitor<OUT = void> { header(ctx: HeaderCstContext): OUT }
export interface TypesDeclaratorsVisitor<OUT = void> { typesDeclarators(ctx: TypesDeclaratorsCstContext): OUT }
export interface ConstantsDeclaratorsVisitor<OUT = void> { constantsDeclarators(ctx: ConstantsDeclaratorsCstContext): OUT }
export interface VariablesDeclaratorsVisitor<OUT = void> { variablesDeclarators(ctx: VariablesDeclaratorsCstContext): OUT }
export interface ProgramVisitor<OUT = void> { program(ctx: ProgramCstContext): OUT }
export interface StatementVisitor<OUT = void> { statement(ctx: StatementCstContext): OUT }
export interface AssignmentStatementVisitor<OUT = void> { assignmentStatement(ctx: AssignmentStatementCstContext): OUT }
export interface ControlStatementsVisitor<OUT = void> { controlStatements(ctx: ControlStatementsCstContext): OUT }
export interface OperationsStatementsVisitor<OUT = void> { operationsStatements(ctx: OperationsStatementsCstContext): OUT }
export interface IterationStatementsVisitor<OUT = void> { iterationStatements(ctx: IterationStatementsCstContext): OUT }
export interface DoWhileStatementVisitor<OUT = void> { doWhileStatement(ctx: DoWhileStatementCstContext): OUT }
export interface WhileDoStatementVisitor<OUT = void> { whileDoStatement(ctx: WhileDoStatementCstContext): OUT }
export interface ForLoopStatementVisitor<OUT = void> { forLoopStatement(ctx: ForLoopStatementCstContext): OUT }
export interface ConditionalStatementsVisitor<OUT = void> { conditionalStatements(ctx: ConditionalStatementsCstContext): OUT }
export interface IfStatementVisitor<OUT = void> { ifStatement(ctx: IfStatementCstContext): OUT }
export interface ElseStatementVisitor<OUT = void> { elseStatement(ctx: ElseStatementCstContext): OUT }
export interface SwitchStatementVisitor<OUT = void> { switchStatement(ctx: SwitchStatementCstContext): OUT }
export interface ExpressionVisitor<OUT = void> { expression(ctx: ExpressionCstContext): OUT }
export interface TernaryExpressionVisitor<OUT = void> { ternaryExpression(ctx: TernaryExpressionCstContext): OUT }
export interface AdditionExpressionVisitor<OUT = void> { additionExpression(ctx: AdditionExpressionCstContext): OUT }
export interface MultiplicationExpressionVisitor<OUT = void> { multiplicationExpression(ctx: MultiplicationExpressionCstContext): OUT }
export interface LogicalExpressionVisitor<OUT = void> { logicalExpression(ctx: LogicalExpressionCstContext): OUT }
export interface RelationalExpressionVisitor<OUT = void> { relationalExpression(ctx: RelationalExpressionCstContext): OUT }
export interface UnaryExpressionVisitor<OUT = void> { unaryExpression(ctx: UnaryExpressionCstContext): OUT }
export interface ParenthesisExpressionVisitor<OUT = void> { parenthesisExpression(ctx: ParenthesisExpressionCstContext): OUT }
export interface AssignmentExpressionVisitor<OUT = void> { assignmentExpression(ctx: AssignmentExpressionCstContext): OUT }
export interface PrintExpressionVisitor<OUT = void> { printExpression(ctx: PrintExpressionCstContext): OUT }
export interface ReadExpressionVisitor<OUT = void> { readExpression(ctx: ReadExpressionCstContext): OUT }
export interface VariableDeclaratorVisitor<OUT = void> { variableDeclarator(ctx: VariableDeclaratorCstContext): OUT }
export interface VariableAccessVisitor<OUT = void> { variableAccess(ctx: VariableAccessCstContext): OUT }
export interface EnumDeclaratorVisitor<OUT = void> { enumDeclarator(ctx: EnumDeclaratorCstContext): OUT }
export interface ArrayAccessSuffixVisitor<OUT = void> { arrayAccessSuffix(ctx: ArrayAccessSuffixCstContext): OUT }
export interface ArrayAccessVisitor<OUT = void> { arrayAccess(ctx: ArrayAccessCstContext): OUT }
export interface BlockVisitor<OUT = void> { block(ctx: BlockCstContext): OUT }

export type CstNodeTypes = {
  algorithm: AlgorithmCstNode;
  header: HeaderCstNode;
  typesDeclarators: TypesDeclaratorsCstNode;
  constantsDeclarators: ConstantsDeclaratorsCstNode;
  variablesDeclarators: VariablesDeclaratorsCstNode;
  program: ProgramCstNode;
  statement: StatementCstNode;
  assignmentStatement: AssignmentStatementCstNode;
  controlStatements: ControlStatementsCstNode;
  operationsStatements: OperationsStatementsCstNode;
  iterationStatements: IterationStatementsCstNode;
  doWhileStatement: DoWhileStatementCstNode;
  whileDoStatement: WhileDoStatementCstNode;
  forLoopStatement: ForLoopStatementCstNode;
  conditionalStatements: ConditionalStatementsCstNode;
  ifStatement: IfStatementCstNode;
  elseStatement: ElseStatementCstNode;
  switchStatement: SwitchStatementCstNode;
  expression: ExpressionCstNode;
  ternaryExpression: TernaryExpressionCstNode;
  additionExpression: AdditionExpressionCstNode;
  multiplicationExpression: MultiplicationExpressionCstNode;
  logicalExpression: LogicalExpressionCstNode;
  relationalExpression: RelationalExpressionCstNode;
  unaryExpression: UnaryExpressionCstNode;
  parenthesisExpression: ParenthesisExpressionCstNode;
  assignmentExpression: AssignmentExpressionCstNode;
  printExpression: PrintExpressionCstNode;
  readExpression: ReadExpressionCstNode;
  variableDeclarator: VariableDeclaratorCstNode;
  variableAccess: VariableAccessCstNode;
  enumDeclarator: EnumDeclaratorCstNode;
  arrayAccessSuffix: ArrayAccessSuffixCstNode;
  arrayAccess: ArrayAccessCstNode;
  block: BlockCstNode;
};
